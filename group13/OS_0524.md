## Topic 1: Format String Attack

### Formatting indicators of printf

We know that most of the formatting indicators are used for format output, such as "%s" and "%d".

While there are some special indicators like "%n".
It calculates how many characters should have been output already at the place it appears in the string and stores it into the next argument.

In the following example, $6$ is stored into $i$.

```C++
int i = 0;
printf("Hello %nworld\n", &i);
printf("i=%d\n", i);
```

### Format string attack

Consider the following fragment from a C program.

```C++
char *s = "Hello World";
printf("%s", s);
```

It can be written as follows as well, because the first argument of $printf$ is a format string, while a string without formatting information is also legal.

```C++
char *s = "Hello World";
printf(s);
```

Then we may do this. Read a string from input and output it with some additional information.

```C++
char s[100], g[100] = "Hello ";
gets(s);
strcat(g, s);
printf(g);
```

However, the input may contain some formatting indicators and the things will change.
The "%n" indicator we mentioned above can overwrite memory. So we can overwrite the return address of the $printf$ function on the stack and jump somewhere else.

The attacker may supply only the format string to $printf$. When $printf$ needs a second parameter, it will take the next value on the stack and use that.
So the attacker can write anything to an address on the stack.

For example, the format string is "%08x %n", and it will write $9$ to the address of second value on the stack.

![](format_string_attack.png)

## Topic 2: 'Full-Nelson.c' Local Privilege Escalation

https://www.exploit-db.com/exploits/15704

This exploit leverages three vulnerabilities to get root, all of which were discovered by Nelson Elhage:

CVE-2010-4258
-------------
This is the interesting one, and the reason I wrote this exploit.  If a thread is created via clone(2) using the CLONE_CHILD_CLEARTID flag, a NULL word will be written to a user-specified pointer when that thread exits. This write is done using put_user(), which ensures the provided destination resides in valid userspace by invoking access_ok().  However, Nelson discovered that when the kernel performs an address limit override via set_fs(KERNEL_DS) and the thread subsequently OOPSes (via BUG, page fault, etc.), this override is not reverted before calling put_user() in the exit path, allowing a user to write a NULL word to an arbitrary kernel address. Note that this issue requires an additional vulnerability to trigger.

CVE-2010-3849
-------------
This is a NULL pointer dereference in the Econet protocol. By itself, it's fairly benign as a local denial-of-service.  It's a perfect candidate to trigger the above issue, since it's reachable via sock_no_sendpage(), which subsequently calls sendmsg under KERNEL_DS.

CVE-2010-3850
-------------
I wouldn't be able to reach the NULL pointer dereference and trigger the OOPS if users weren't able to assign Econet addresses to arbitrary interfaces due to a missing capabilities check.